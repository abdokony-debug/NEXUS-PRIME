# nexus_prime.py
import os
import sys
import json
import uuid
import asyncio
import logging
import aiohttp
from datetime import datetime, timedelta
from typing import List, Dict, Optional
from urllib.parse import urlparse
from supabase import create_client
import re

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('nexus_prime.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

SUPABASE_URL = os.getenv('SUPABASE_URL', '')
SUPABASE_KEY = os.getenv('SUPABASE_KEY', '')
GOOGLE_API_KEY = os.getenv('GOOGLE_API_KEY', '')
GOOGLE_CX = os.getenv('GOOGLE_CX', '')

class Platform:
    TWITTER = "twitter"
    LINKEDIN = "linkedin"
    EMAIL = "email"
    GITHUB = "github"
    GENERIC = "generic"

class LeadStatus:
    NEW = "new"
    CONTACTED = "contacted"
    CONVERTED = "converted"

class CampaignStatus:
    ACTIVE = "active"
    PAUSED = "paused"
    COMPLETED = "completed"

class Lead:
    def __init__(self):
        self.id = str(uuid.uuid4())
        self.campaign_id = ""
        self.url = ""
        self.platform = Platform.GENERIC
        self.name = ""
        self.email = ""
        self.company = ""
        self.intent_score = 0.0
        self.content_summary = ""
        self.status = LeadStatus.NEW
        self.message_sent = False
        self.created_at = datetime.now()
    
    def to_dict(self):
        return {
            'id': self.id,
            'campaign_id': self.campaign_id,
            'url': self.url,
            'platform': self.platform,
            'name': self.name,
            'email': self.email,
            'company': self.company,
            'intent_score': self.intent_score,
            'content_summary': self.content_summary[:500],
            'status': self.status,
            'message_sent': self.message_sent,
            'created_at': self.created_at.isoformat()
        }

class Campaign:
    def __init__(self):
        self.id = ""
        self.name = ""
        self.keywords = []
        self.usp = ""
        self.product_link = ""
        self.max_leads = 100
        self.min_intent_score = 70.0
        self.status = CampaignStatus.ACTIVE
    
    @classmethod
    def from_db(cls, data: Dict):
        campaign = cls()
        campaign.id = data.get('id', '')
        campaign.name = data.get('name', '')
        campaign.keywords = [k.strip() for k in data.get('keywords', '').split(',') if k.strip()]
        campaign.usp = data.get('usp', '')
        campaign.product_link = data.get('product_link', '')
        campaign.max_leads = data.get('max_leads', 100)
        campaign.min_intent_score = data.get('min_intent_score', 70.0)
        campaign.status = data.get('status', CampaignStatus.ACTIVE)
        return campaign

class DatabaseService:
    def __init__(self):
        self.client = create_client(SUPABASE_URL, SUPABASE_KEY)
        logger.info("Database connected")
    
    def get_active_campaigns(self) -> List[Campaign]:
        try:
            res = self.client.table('campaigns').select('*').eq('status', 'active').execute()
            return [Campaign.from_db(row) for row in res.data]
        except Exception as e:
            logger.error(f"Get campaigns error: {e}")
            return []
    
    def get_campaign(self, campaign_id: str) -> Optional[Campaign]:
        try:
            res = self.client.table('campaigns').select('*').eq('id', campaign_id).execute()
            if res.data:
                return Campaign.from_db(res.data[0])
            return None
        except Exception as e:
            logger.error(f"Get campaign error: {e}")
            return None
    
    def insert_lead(self, lead: Lead) -> bool:
        try:
            self.client.table('leads').insert(lead.to_dict()).execute()
            return True
        except Exception as e:
            logger.error(f"Insert lead error: {e}")
            return False
    
    def get_campaign_stats(self, campaign_id: str) -> Dict:
        try:
            res = self.client.table('leads').select('*').eq('campaign_id', campaign_id).execute()
            leads = res.data
            total = len(leads)
            contacted = sum(1 for lead in leads if lead.get('message_sent', False))
            converted = sum(1 for lead in leads if lead.get('status') == LeadStatus.CONVERTED)
            
            return {
                'total_leads': total,
                'contacted_leads': contacted,
                'converted_leads': converted,
                'conversion_rate': (converted / total * 100) if total > 0 else 0
            }
        except Exception as e:
            logger.error(f"Get stats error: {e}")
            return {}
    
    def update_campaign_status(self, campaign_id: str, status: str):
        try:
            self.client.table('campaigns').update({'status': status}).eq('id', campaign_id).execute()
        except Exception as e:
            logger.error(f"Update campaign error: {e}")

class IntentAnalyzer:
    def __init__(self):
        try:
            from transformers import pipeline
            self.classifier = pipeline("zero-shot-classification", model="facebook/bart-large-mnli")
            logger.info("Intent analyzer initialized")
        except Exception as e:
            logger.warning(f"Transformers not available: {e}")
            self.classifier = None
    
    def analyze(self, text: str) -> float:
        if not text or len(text) < 10:
            return 0.0
        
        if self.classifier:
            return self._analyze_transformers(text)
        return self._analyze_fallback(text)
    
    def _analyze_transformers(self, text: str) -> float:
        try:
            labels = ["buying intent", "researching", "complaining", "casual"]
            result = self.classifier(text[:500], labels)
            top_score = result['scores'][0] * 100
            
            if result['labels'][0] == "buying intent":
                return top_score
            elif result['labels'][0] == "researching":
                return top_score * 0.7
            else:
                return top_score * 0.3
        except Exception as e:
            logger.error(f"Transformers analysis error: {e}")
            return self._analyze_fallback(text)
    
    def _analyze_fallback(self, text: str) -> float:
        keywords = {
            'buy': 90, 'purchase': 85, 'need': 80, 'looking for': 75,
            'problem': 70, 'solution': 65, 'review': 60, 'compare': 55
        }
        
        text_lower = text.lower()
        max_score = 0
        
        for keyword, score in keywords.items():
            if keyword in text_lower:
                max_score = max(max_score, score)
        
        if max_score == 0:
            max_score = 40 if len(text) > 100 else 20
        
        return float(max_score)

class LeadFinder:
    def __init__(self):
        self.session = None
    
    async def search(self, query: str, num_results: int = 10) -> List[str]:
        if not GOOGLE_API_KEY or not GOOGLE_CX:
            logger.warning("Google API keys not found, using fallback")
            return self._fallback_search(query, num_results)
        
        try:
            async with aiohttp.ClientSession() as session:
                url = "https://www.googleapis.com/customsearch/v1"
                params = {
                    'q': query,
                    'key': GOOGLE_API_KEY,
                    'cx': GOOGLE_CX,
                    'num': min(num_results, 10)
                }
                
                async with session.get(url, params=params, timeout=30) as response:
                    data = await response.json()
                    items = data.get('items', [])
                    return [item['link'] for item in items if 'link' in item]
        except Exception as e:
            logger.error(f"Google search error: {e}")
            return self._fallback_search(query, num_results)
    
    def _fallback_search(self, query: str, num_results: int) -> List[str]:
        platforms = ['twitter.com', 'linkedin.com', 'github.com']
        return [f"https://{platform}/search?q={query.replace(' ', '+')}" for platform in platforms[:num_results]]

class ContentScraper:
    def __init__(self):
        self.session = None
    
    async def scrape(self, url: str) -> Dict:
        try:
            async with aiohttp.ClientSession() as session:
                headers = {'User-Agent': 'Mozilla/5.0'}
                async with session.get(url, headers=headers, timeout=10) as response:
                    html = await response.text()
                    return self._extract_data(html, url)
        except Exception as e:
            logger.error(f"Scrape error for {url}: {e}")
            return {'content': '', 'platform': Platform.GENERIC}
    
    def _extract_data(self, html: str, url: str) -> Dict:
        data = {'content': '', 'platform': Platform.GENERIC}
        
        url_lower = url.lower()
        for platform in [Platform.TWITTER, Platform.LINKEDIN, Platform.GITHUB]:
            if platform in url_lower:
                data['platform'] = platform
                break
        
        text = re.sub(r'<[^>]+>', ' ', html)
        text = re.sub(r'\s+', ' ', text)
        data['content'] = text[:2000]
        
        emails = re.findall(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b', html)
        if emails:
            data['email'] = emails[0]
        
        parsed = urlparse(url)
        path_parts = parsed.path.strip('/').split('/')
        if path_parts:
            data['name'] = path_parts[0].replace('-', ' ').title()
        
        return data

class Messenger:
    def __init__(self):
        self.sent_count = 0
    
    async def send(self, lead: Lead, campaign: Campaign) -> bool:
        logger.info(f"[MESSENGER] Would send to: {lead.url}")
        logger.info(f"[MESSENGER] Platform: {lead.platform}")
        logger.info(f"[MESSENGER] Score: {lead.intent_score}")
        logger.info(f"[MESSENGER] Message preview generated")
        
        lead.message_sent = True
        lead.status = LeadStatus.CONTACTED
        self.sent_count += 1
        return True

class NexusPrime:
    def __init__(self):
        self.db = DatabaseService()
        self.analyzer = IntentAnalyzer()
        self.finder = LeadFinder()
        self.scraper = ContentScraper()
        self.messenger = Messenger()
        self.processed_count = 0
    
    async def process_campaign(self, campaign_id: str) -> Dict:
        logger.info(f"Processing campaign: {campaign_id}")
        
        campaign = self.db.get_campaign(campaign_id)
        if not campaign:
            return {"error": "Campaign not found"}
        
        if campaign.status != CampaignStatus.ACTIVE:
            return {"error": "Campaign is not active"}
        
        logger.info(f"Campaign: {campaign.name}")
        logger.info(f"Keywords: {', '.join(campaign.keywords)}")
        
        query = " ".join(campaign.keywords)
        urls = await self.finder.search(query, campaign.max_leads)
        
        logger.info(f"Found {len(urls)} potential leads")
        
        results = {
            "campaign_id": campaign_id,
            "campaign_name": campaign.name,
            "total_found": len(urls),
            "processed": 0,
            "qualified": 0,
            "sent": 0,
            "leads": []
        }
        
        for url in urls[:campaign.max_leads]:
            try:
                scraped = await self.scraper.scrape(url)
                intent_score = self.analyzer.analyze(scraped['content'])
                
                if intent_score >= campaign.min_intent_score:
                    lead = Lead()
                    lead.campaign_id = campaign.id
                    lead.url = url
                    lead.platform = scraped['platform']
                    lead.name = scraped.get('name', '')
                    lead.email = scraped.get('email', '')
                    lead.intent_score = intent_score
                    lead.content_summary = scraped['content'][:500]
                    
                    if self.db.insert_lead(lead):
                        results["qualified"] += 1
                        results["leads"].append({
                            "url": url,
                            "score": intent_score,
                            "platform": scraped['platform']
                        })
                        
                        await self.messenger.send(lead, campaign)
                        results["sent"] += 1
                
                results["processed"] += 1
                self.processed_count += 1
                
                await asyncio.sleep(1)
                
            except Exception as e:
                logger.error(f"Error processing {url}: {e}")
                await asyncio.sleep(2)
        
        stats = self.db.get_campaign_stats(campaign_id)
        if stats.get('total_leads', 0) >= campaign.max_leads:
            self.db.update_campaign_status(campaign_id, CampaignStatus.COMPLETED)
            logger.info(f"Campaign {campaign.name} completed")
        
        results["final_stats"] = stats
        return results
    
    async def process_all_active(self) -> List[Dict]:
        campaigns = self.db.get_active_campaigns()
        results = []
        
        logger.info(f"Found {len(campaigns)} active campaigns")
        
        for campaign in campaigns:
            result = await self.process_campaign(campaign.id)
            results.append(result)
            await asyncio.sleep(5)
        
        return results
    
    def get_stats(self) -> Dict:
        return {
            "processed_total": self.processed_count,
            "messages_sent": self.messenger.sent_count
        }

def main_menu():
    print("\n" + "="*50)
    print("NEXUS-PRIME - Outreach System")
    print("="*50)
    print("1. Process all active campaigns")
    print("2. Process specific campaign")
    print("3. Show system stats")
    print("4. Exit")
    print("="*50)
    
    choice = input("\nSelect option (1-4): ").strip()
    return choice

async def run_system():
    system = NexusPrime()
    
    while True:
        choice = main_menu()
        
        if choice == "1":
            print("\nProcessing all active campaigns...")
            results = await system.process_all_active()
            
            for result in results:
                print(f"\nCampaign: {result.get('campaign_name')}")
                print(f"Processed: {result.get('processed')}")
                print(f"Qualified: {result.get('qualified')}")
                print(f"Messages sent: {result.get('sent')}")
        
        elif choice == "2":
            campaign_id = input("\nEnter campaign ID: ").strip()
            if campaign_id:
                print(f"\nProcessing campaign {campaign_id}...")
                result = await system.process_campaign(campaign_id)
                
                if "error" in result:
                    print(f"Error: {result['error']}")
                else:
                    print(f"\nCampaign: {result.get('campaign_name')}")
                    print(f"Total found: {result.get('total_found')}")
                    print(f"Processed: {result.get('processed')}")
                    print(f"Qualified: {result.get('qualified')}")
                    print(f"Messages sent: {result.get('sent')}")
                    
                    if result.get('final_stats'):
                        stats = result['final_stats']
                        print(f"\nFinal Stats:")
                        print(f"  Total leads: {stats.get('total_leads', 0)}")
                        print(f"  Contacted: {stats.get('contacted_leads', 0)}")
                        print(f"  Converted: {stats.get('converted_leads', 0)}")
                        print(f"  Conversion rate: {stats.get('conversion_rate', 0):.1f}%")
            else:
                print("Campaign ID required")
        
        elif choice == "3":
            stats = system.get_stats()
            print("\nSystem Statistics:")
            print(f"Total processed: {stats['processed_total']}")
            print(f"Messages sent: {stats['messages_sent']}")
        
        elif choice == "4":
            print("\nExiting NEXUS-PRIME...")
            break
        
        else:
            print("\nInvalid option")

if __name__ == "__main__":
    if not SUPABASE_URL or not SUPABASE_KEY:
        print("ERROR: SUPABASE_URL and SUPABASE_KEY environment variables are required")
        print("Set them in your environment or create a .env file")
        sys.exit(1)
    
    print("NEXUS-PRIME System Starting...")
    print(f"Supabase URL: {SUPABASE_URL[:30]}...")
    print(f"Google API Key: {'Set' if GOOGLE_API_KEY else 'Not set'}")
    
    asyncio.run(run_system())
